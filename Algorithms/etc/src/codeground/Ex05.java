package codeground;

import java.util.Scanner;

public class Ex05 {
	static int Answer;
	static long P = 1000000007;
	public static int N, M;
	public static long[] factorial = new long[2000003];

	public static long combination(int n, int r) {
		long A = factorial[n];
		long B = factorial[n - r] * factorial[r] % P;

		return A * find(B, P - 2) % P;
	}

	public static long find(long B, long p) {
		if (p == 0)
			return 1;
		else if (p == 1)
			return B;
		else {
			long half = find(B, p / 2);

			if (p % 2 == 0)
				return (half * half) % P;
			else
				return ((half * half) % P * B) % P;
		}
	}

	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		factorial[0] = 1;
		for (int i = 1; i < 2000003; i++)
			factorial[i] = i * factorial[i - 1] % P;

		int T = sc.nextInt();

		for (int test_case = 0; test_case < T; test_case++) {
			N = sc.nextInt();
			M = sc.nextInt();
			Answer = (int) (combination(M + N + 2, N + 1) - 1);

			System.out.println("Case #" + (test_case + 1));
			System.out.println(Answer);
		}
	}
}

/*
 * description is from garion
 * 
 * 일단 주어진 식이 N+M+2 개 중에서 N+1개를 고르는 경우의 수를 구하는 문제로 바뀌는 부분까지 도달했다고 하자.
 *
 * 그렇다면, Combination의 값을 구하는 것에 대해서 이야기해보자. 일단, n개중에서 r개를 뽑는 경우의 수를 nCr이라고
 * 표기하겠다. (n, r은 0이상의 정수이고 r <= n이다) 그렇다면, nCr = n! / ((n-r)! * r!)이고, 우리가 정말로
 * 구하려는 값은 nCr % 1,000,007이다.(이하 A := n!, B := (n-r)! * r!, P := 1,000,007) 그런데,
 * 여기서 문제는 모듈러 연산은 덧셈 곱셈에 대해선 분배 법칙이 성립하지만 나눗셈에 대해서는 성립하지 않기 때문에 현재 nCr은
 * factorial의 나눗셈을 한 후에 % 연산을 해야한다는 것이다. 그러나, 우리는 제한된 bit수의 정수형을 사용해야하기 때문에
 * factorial 자체에 % 연산을 적용한 것을 저장할 수밖에 없다. 그렇다면, 일단 나눗셈을 곱셈 형태로 바꾸어야 하는데 B를 일반적인
 * 나눗셈의 역원인 1/B로 바꾸는 것이 모듈러 연산에서는 통하지 않기 때문에 페르마의 소정리를 이용해야 한다.
 *
 * 페르마의 소정리란, p가 소수이고, a가 정수이며, a와 p가 서로소(공약수가 1뿐인 것을 뜻함)라고 하자. 페르마의 소정리에 따르면, 법
 * p에서 a^p a는 서로 합동(p로 나눈 나머지가 같음을 뜻함)이다. a^p == a (mod p) 이 참일때 a^p와 a를 합동이라고
 * 한다.( A == B (mod C) := A와 B를 각각 C로 나누었을때 나머지가 같다는 뜻) a^p와 a가 합동이면, a^(p-1) ==
 * 1 (mod p) 도 참이다.
 *
 * 이걸 위의 사례에 적용을 하면, B^(P-1) == 1 (mod P) A * B^(P-1) == A (mod P) // 양변에 A를
 * 곱해주었다. A * B^(P-2) == A/B (mod P) // 양변에 B를 나누어주었다. (A * B^(P-2)) % P ==
 * (A/B) % P (mod P) // 양변에 % P 를 해주었다. (A % P) * (B^(P-2) % P) == (A/B) % P
 * (mod P) // 좌변에 곱셈 분배법칙을 적용하였다.
 *
 * # B로 양변을 나누기 전에 A를 곱해준 이유는 B로 먼저 나눌 경우에 우변의 값은 정수가 아닌데 좌변의 값은 정수가 되는 문제가 발생하기
 * 때문이다.
 *
 * 이제 실제 계산해보면 좌변의 값이 P보다 커질 수 있기 때문에 % P를 한번 더 해주면 우변의 값과 같다. 이제 문제는 B^(P-2) %
 * P의 값을 구하는 것으로 바뀌었다. 그런데 앞서 설명했듯이, 곱셈의 분배 법칙이 성립하므로 a^b == (a^(b/2) % c)^2
 * (mod c) (b가 짝수인 경우, 홀수이면 우측에 a만큼을 곱해주면 된다)를 이용하면 O(lg b)의 시간으로 B^(P-2) % P의
 * 값을 구할 수 있다.
 */

/*
 * description is from Sunny Jeon
 * 
 * 1. combination의 변환 (N + M, N) = (N+M)! / (N! * M!) (0) 이항 계수의 합 공식: (0, k) +
 * (1, k) + (2, k) + (3, k) + ... + (n, k) = (n + 1, k + 1) 이항계수의 합을 구할 때, 이런
 * 성질을 이용하면 Sigma(i->N) (i, k) = (N + 1, k + 1)로 변형을 시킬 수 있습니다. (1)
 * Sigma(i->N)Sigma(j->M) (i + j, i)를 구할 때, 앞에 있는 j->M에 대한 시그마를 없애볼겠습니다. (2) =
 * Sigma(i->N) (i + M + 1, i) (3) = (N + M + 2, N + 1) 여기서 주의해야 할 것이 있는데, (0,
 * 0)이 고정적으로 더해지기 때문에 1을 빼줘야한다는 것입니다. 즉, 이 문제는 (N+M+2)! / (N! * M!) - 1을 구하는 문제가
 * 되겠습니다.
 * 
 * 2. Factorial factorial 값이 무지막지하게 커지면 컴퓨터가 나누는 연산을 할 수 없게 됩니다. 그래서 우리는
 * factorial된 값을 나눈 나머지까지만 배열에 넣을 것입니다. 나눈 값은, 아래 페르마의 소정리를 응용해서 풉니다. 이는 쉽게 구할 수
 * 있기 때문에 미리 모든 범위의 2백만2개의 계산결과를 넣습니다.
 *
 * 3. Fermat(페르마)의 소정리 간단한 이론은 서로소인 x, P가 있을 때 (1) x의 (P-1)제곱을 P로 나눈 나머지를 나타낸 식
 * (2) 1을 P로 나눈 나머지를 나타낸 식 이 경우, (1)과 (2)를 합동식이라 하며, 언제든 함께 나타낼 수 있습니다. (3) 즉,
 * x^(P-1) = 1 (% P) 라는 것이다. 다행히 우리에게 주어진 수 1000000007은 소수이기 때문에 이 숫자로 나누는 경우 위의
 * 성질을 만족한다는 것입니다. 그래서, 저는 (N+M)!을 A로, N!M!을 B로 대입해 볼 것입니다. 그러면 우리는 (A/B)를 P로 나눈
 * 값만 구하면 되고 (3)에서 좌변과 우변 모두 (A/B)를 공평하게 곱해준다. 여기서 x에 B를 대입해봅시다. 즉, (3)을 다시 쓰면,
 * B^(P-1) = 1 (% P) B^(P-2) = (1 / B) (% P) A * B^(P-2) = (A / B) (% P) 즉, 저는 A
 * * B^(P-2)를 P로 나눈 나머지만 구하면 되는 것입니다. 그런데 2^10000 이런 숫자를 어떻게 구하는지 또 막막하시죠? 이젠,
 * 제곱수를 O(logn)의 시간 복잡도로 풀어내보면 됩니다.
 *
 * 4. 페르마의 소정리 응용: 제곱수의 나머지 페르마의 소정리가 제곱수를 쪼개주는 역할을 합니다. 제곱을 포함해 모든 연산은 이런 성질이
 * 있습니다. 덧셈을 예로 들어보죠. (A % P + B % P) = (A + B) % P ex) 100을 13으로 나눈 나머지(9) +
 * 25를 13으로 나눈 나머지(12) = 21을 13으로 나눈 나머지 = 8 100+25 = 125를 13으로 나눈 나머지는 또 8입니다.
 * 신기하죠? 덧셈 외에도 이는 곱셈에도 적용이 됩니다. 예를 들어 A^4 = A^2 * A^2가 되는데 이 경우에도 이 세개의 수를 나눈
 * 나머지가 서로 일치합니다. 그러면 우리는 굳이 2^10000을 구할 필요 없이 10000 -> 5000 -> 2500 -> 1250 ->
 * 625 -> 312 ->... 저렇게 625에서 312로 넘어오는 경우 2가 남는데, 이 경우 앞에 그대로 2만 곱해주고 나머지를 구하면
 * 됩니다. 간단한 예를 들어보면 x^(p-2)를 p로 나눈 나머지를 예로 들면, x를 2라 하고, p를 13이라 해봅시다.
 * 2^11=2048을 13으로 나눈 나머지는 7이 나오는데 (1) 11을 2로 나눠 쪼개면 5가 남고, 1이 나머지로 나오는데(2 *
 * (2^2)^5 = 2 * 4^5 = 2^11) 지금 변형된 식은 그러면 2 * (4 ^ 5)입니다. (2) 5를 2로 나눠 쪼개면 2가
 * 남고, 1이 나머지로 오기에, 2 앞에 4를 곱해서 다음과 같은 식을 만듭시다. 그러면 변형된 식은 8 * (4 ^ 2)^2입니다.
 * 그러면, 8 * (16)^2가 됩니다. 8을 13으로 나눠도 그대로 8인데, 16을 13으로 나누면 3이 되죠? 이로써 변형된 식은 8 *
 * (3)^2입니다. 2는 그대로 나눠지기 때문에 뒤를 1로 만들어주면, 72 * 1이 됩니다. (3) 72를 다시 13으로 나눈 나머지는
 * 72 % 13 = 7입니다. 그래서 2^11 % 13 = 72 % 13 = 7이 됩니다.
 */