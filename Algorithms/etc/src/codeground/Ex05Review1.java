/*
 * 일단 주어진 식이 N+M+2 개 중에서 N+1개를 고르는 경우의 수를 구하는 문제로 바뀌는 부분까지 도달했다고 하자.
 *
 * 그렇다면, Combination의 값을 구하는 것에 대해서 이야기해보자.
 * 일단, n개중에서 r개를 뽑는 경우의 수를 nCr이라고 표기하겠다. (n, r은 0이상의 정수이고 r <= n이다)
 * 그렇다면, nCr = n! / ((n-r)! * r!)이고, 우리가 정말로 구하려는 값은 nCr % 1,000,007이다.(이하 A := n!, B := (n-r)! * r!, P := 1,000,007)
 * 그런데, 여기서 문제는 모듈러 연산은 덧셈 곱셈에 대해선 분배 법칙이 성립하지만 나눗셈에 대해서는 성립하지 않기 때문에 현재 nCr은 factorial의 나눗셈을 한 후에 % 연산을 해야한다는 것이다.
 * 그러나, 우리는 제한된 bit수의 정수형을 사용해야하기 때문에 factorial 자체에 % 연산을 적용한 것을 저장할 수밖에 없다.
 * 그렇다면, 일단 나눗셈을 곱셈 형태로 바꾸어야 하는데 B를 일반적인 나눗셈의 역원인 1/B로 바꾸는 것이 모듈러 연산에서는 통하지 않기 때문에 페르마의 소정리를 이용해야 한다.
 *
 * 페르마의 소정리란, p가 소수이고, a가 정수이며, a와 p가 서로소(공약수가 1뿐인 것을 뜻함)라고 하자. 페르마의 소정리에 따르면, 법 p에서 a^p a는 서로 합동(p로 나눈 나머지가 같음을 뜻함)이다.
 * a^p == a (mod p) 이 참일때 a^p와 a를 합동이라고 한다.( A == B (mod C) := A와 B를 각각 C로 나누었을때 나머지가 같다는 뜻)
 * a^p와 a가 합동이면, a^(p-1) == 1 (mod p) 도 참이다.
 *
 * 이걸 위의 사례에 적용을 하면,
 * B^(P-1) == 1 (mod P)
 * A * B^(P-1) == A (mod P) // 양변에 A를 곱해주었다.
 * A * B^(P-2) == A/B (mod P) // 양변에 B를 나누어주었다.
 * (A * B^(P-2)) % P == (A/B) % P (mod P) // 양변에 % P 를 해주었다.
 * (A % P) * (B^(P-2) % P) == (A/B) % P (mod P) // 좌변에 곱셈 분배법칙을 적용하였다.
 *
 * # B로 양변을 나누기 전에 A를 곱해준 이유는 B로 먼저 나눌 경우에 우변의 값은 정수가 아닌데 좌변의 값은 정수가 되는 문제가 발생하기 때문이다.
 *
 * 이제 실제 계산해보면 좌변의 값이 P보다 커질 수 있기 때문에 % P를 한번 더 해주면 우변의 값과 같다.
 * 이제 문제는 B^(P-2) % P의 값을 구하는 것으로 바뀌었다.
 * 그런데 앞서 설명했듯이, 곱셈의 분배 법칙이 성립하므로 a^b == (a^(b/2) % c)^2 (mod c) (b가 짝수인 경우, 홀수이면 우측에 a만큼을 곱해주면 된다)를 이용하면
 * O(lg b)의 시간으로 B^(P-2) % P의 값을 구할 수 있다.
 * 
 * 4. 페르마의 소정리 응용: 제곱수의 나머지 페르마의 소정리가 제곱수를 쪼개주는 역할을 합니다. 제곱을 포함해 모든 연산은 이런 성질이
 * 있습니다. 덧셈을 예로 들어보죠. (A % P + B % P) = (A + B) % P ex) 100을 13으로 나눈 나머지(9) +
 * 25를 13으로 나눈 나머지(12) = 21을 13으로 나눈 나머지 = 8 100+25 = 125를 13으로 나눈 나머지는 또 8입니다.
 * 신기하죠? 덧셈 외에도 이는 곱셈에도 적용이 됩니다. 예를 들어 A^4 = A^2 * A^2가 되는데 이 경우에도 이 세개의 수를 나눈
 * 나머지가 서로 일치합니다. 그러면 우리는 굳이 2^10000을 구할 필요 없이 10000 -> 5000 -> 2500 -> 1250 ->
 * 625 -> 312 ->... 저렇게 625에서 312로 넘어오는 경우 2가 남는데, 이 경우 앞에 그대로 2만 곱해주고 나머지를 구하면
 * 됩니다. 간단한 예를 들어보면 x^(p-2)를 p로 나눈 나머지를 예로 들면, x를 2라 하고, p를 13이라 해봅시다.
 * 2^11=2048을 13으로 나눈 나머지는 7이 나오는데 (1) 11을 2로 나눠 쪼개면 5가 남고, 1이 나머지로 나오는데(2 *
 * (2^2)^5 = 2 * 4^5 = 2^11) 지금 변형된 식은 그러면 2 * (4 ^ 5)입니다. (2) 5를 2로 나눠 쪼개면 2가
 * 남고, 1이 나머지로 오기에, 2 앞에 4를 곱해서 다음과 같은 식을 만듭시다. 그러면 변형된 식은 8 * (4 ^ 2)^2입니다.
 * 그러면, 8 * (16)^2가 됩니다. 8을 13으로 나눠도 그대로 8인데, 16을 13으로 나누면 3이 되죠? 이로써 변형된 식은 8 *
 * (3)^2입니다. 2는 그대로 나눠지기 때문에 뒤를 1로 만들어주면, 72 * 1이 됩니다. (3) 72를 다시 13으로 나눈 나머지는
 * 72 % 13 = 7입니다. 그래서 2^11 % 13 = 72 % 13 = 7이 됩니다.
 */

package codeground;

import java.util.Scanner;

public class Ex05Review1 {
	static int[] factorial = new int[10000000];
	static final int P = 1_000_000_007;

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		factorial[0] = 1;
		for (int i = 1; i < 10000000; i++)
			factorial[i] = factorial[i - 1] * i % P;

		int N = sc.nextInt();
		int M = sc.nextInt();

		System.out.println(combination(N + M + 2, N + 1) - 1);
	}

	public static long combination(int n, int r) {
		int A = factorial[n];
		int B = factorial[n - r] * factorial[r] % P;
		return A * findMMI(B, P - 2) % P;
	}

	public static long findMMI(long B, long p) {
		if (p == 0)
			return 1;
		else if (p == 1)
			return B;
		else {
			long half = findMMI(B, p / 2);

			if (p % 2 == 0)
				return (half * half) % P;
			else
				return ((half * half) % P * B) % P;
		}
	}

}
